// примери за асемблерен код
// намиране на сумата на елементите на масив 
// Източник на кода: ФМИ, ПУ

// Допълнителни коментари в кода по-долу:
// Тодор "Twenkid" Арнаудов
// http://twenkid.com
// http://artificial-mind.blogspot.bg
#include <iostream>
using namespace std;
void View(int *a, int L) {
  for (int i = L - 1; 0 <= i; --i) cout << a[i] << "  ";
  cout << endl;
}
int Sum(int *a, int L) {
  int s = 0;
  for (int i = L - 1; 0 <= i; --i) s += a[i];
  return s;
}
int SumAsm(int *a, int L) {
  __asm {
    push esi	//праща в стека
        xor eax, eax		//нулира eax -- xor reg,reg е равносилно на mov reg, 0  (mov eax,0  ... mov ecx,0) но е по-ефективно
        mov ecx, L			//броячът ecx = дължината на масива
        mov esi, a			//esi - адресът на нулевия елемент на масива
      NEXT : add eax, [esi + ecx * 4 - 4]  //натрупва стойността в акумулатора eax = eax + a[ecx] ... 
										//Изразите като този в скобите са адресна аритметика, esi е базов регистър (нулевия елемент),
										//ecx е номерът на елемента, *4 - защото 4 байта е размерът на елемент;
										//-4 е защото масивите започват от [0], но дължината се очаква да е поне 1
										//И дължината е с едно по-голяма от последния валиден елемент.
										//if L==1, валидно е само a[0]
										//Затова първата стойност на ecx се очаква да е поне 1.
										//Ако се прати L == 0 може да се получи грешка, защото процесорът ще опита да прочете един адрес (4 байта) преди началото на масива.
										//Ако пък няма " - 4" и се прати коректна дължина, процесорът ще прочете с един 4-байтов адрес напред, извън масива.
										
             loop NEXT					//loop проверява дали ecx == 0, ако е --> край, продължава
										//if ecx > 0 ==> { ecx -= 1; jmp NEXT }
										//T.e. събирането започва от последния елемент

    pop esi		//записва в esi старата стойност, от преди асемблерния блок
  }
}
int main(){
  int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  const int len = sizeof(ar) / sizeof(ar[0]);
  View(ar, len);
  cout << "Sum: " << Sum(ar, len) << endl;
  int sum;
  __asm {
    push eax
        xor eax, eax				//Нулира eax, eax = 0
        mov ecx, len				//Зарежда дължината в брояча ecx
      NEXT : add eax, ar[ecx*4-4]	//Като във функцията по-горе, но тук аритметиката е по-проста, защото няма базов регистър esi.
									//Асемблерът "знае" този адрес от локалната променлива ar.
									//В случая с функцията, "a" е просто някакво число, което С++ знае, че е адрес (указател)
									//но за асемблера е просто число, което програмистът интерпретира като начален адрес на масив
									//чрез частта [esi...] в адресната аритметика.
             loop NEXT
        mov sum, eax
    pop eax
  }
  cout << "Sum: " << sum << endl;
  cout << "Sum: " << SumAsm(ar, len) << endl;

  system("pause");
  return 0;
}